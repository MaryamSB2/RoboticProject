"""Spot controller with A* path planning on a 10x10m floor.
Grid resolution: 0.5m (20x20 grid).
"""

from controller import Robot, DistanceSensor, Motor, GPS, InertialUnit
import math
from heapq import heappush, heappop

# ========== Robot and devices ==========
robot = Robot()
time_step = int(robot.getBasicTimeStep())

gps = robot.getDevice('gps'); gps.enable(time_step)
imu = robot.getDevice('inertial unit'); imu.enable(time_step)

ds = []
dsNames = ['ds_front', 'ds_right', 'ds_left']
for name in dsNames:
    s = robot.getDevice(name); s.enable(time_step); ds.append(s)

wheels = []
wheelsNames = ['wheel1','wheel2','wheel3','wheel4']
for name in wheelsNames:
    m = robot.getDevice(name)
    m.setPosition(float('inf'))
    m.setVelocity(0.0)
    wheels.append(m)

def step(): return robot.step(time_step) != -1

# ========== Grid setup ==========
CELL_SIZE = 0.5   # meters
GRID_SIZE = int(10 / CELL_SIZE)  # 20x20

def world_to_grid(x, y):
    i = int((x + 5.0) / CELL_SIZE)   # shift origin to grid
    j = int((y + 5.0) / CELL_SIZE)
    return i, j

def grid_to_world(i, j):
    x = i * CELL_SIZE - 5.0 + CELL_SIZE/2
    y = j * CELL_SIZE - 5.0 + CELL_SIZE/2
    return x, y

# ========== Goal ==========
GOAL_X = -0.061869
GOAL_Y = -0.462078
GOAL_THRESHOLD = 0.30

# ========== Motion ==========
def set_all_wheels(v_left, v_right):
    wheels[0].setVelocity(v_left); wheels[2].setVelocity(v_left)
    wheels[1].setVelocity(v_right); wheels[3].setVelocity(v_right)

def stop(): set_all_wheels(0.0,0.0)

def go_to_goal(robot_pos, yaw, target_x, target_y):
    x,y,z = robot_pos
    dx, dy = target_x - x, target_y - y
    desired_yaw = math.atan2(dy, dx)
    angle_error = desired_yaw - yaw
    while angle_error > math.pi: angle_error -= 2*math.pi
    while angle_error < -math.pi: angle_error += 2*math.pi
    dist = math.hypot(dx, dy)

    K_omega, K_v = 3.0, 4.0
    omega = K_omega * angle_error
    v = K_v * max(0.0, math.cos(angle_error))
    WHEEL_TRACK = 0.6
    v_left  = v - (omega * WHEEL_TRACK / 2.0)
    v_right = v + (omega * WHEEL_TRACK / 2.0)

    max_v = wheels[0].getMaxVelocity()
    v_left  = max(-max_v, min(max_v, v_left))
    v_right = max(-max_v, min(max_v, v_right))
    set_all_wheels(v_left, v_right)
    return dist

# ========== A* ==========
def astar(start, goal, grid):
    open_set = []
    heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}

    while open_set:
        _, current = heappop(open_set)
        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]

        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
            neighbor = (current[0]+dx, current[1]+dy)
            if not (0 <= neighbor[0] < GRID_SIZE and 0 <= neighbor[1] < GRID_SIZE):
                continue
            if grid[neighbor[0]][neighbor[1]] == 1:  # obstacle
                continue
            tentative_g = g_score[current] + 1
            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                h = math.hypot(goal[0]-neighbor[0], goal[1]-neighbor[1])
                f = tentative_g + h
                heappush(open_set, (f, neighbor))
                came_from[neighbor] = current
    return []

# ========== Main ==========
grid = [[0]*GRID_SIZE for _ in range(GRID_SIZE)]

start = None
goal = world_to_grid(GOAL_X, GOAL_Y)
path = []
waypoints = []
wp_index = 0

while step():
    pos = gps.getValues()
    if math.isnan(pos[0]) or math.isnan(pos[2]):
        print("Waiting for GPS...")
        continue

    roll,pitch,yaw = imu.getRollPitchYaw()
    dsValues = [s.getValue() for s in ds]

    # Initialize path once GPS is ready
    if start is None:
        start = world_to_grid(pos[0], pos[2])
        path = astar(start, goal, grid)
        waypoints = [grid_to_world(i,j) for (i,j) in path]
        wp_index = 0
        print("Initial path computed with", len(waypoints), "waypoints")

    # Dynamic obstacle marking
    if dsValues[0] < 350.0:  # front sensor
        i,j = world_to_grid(pos[0]+math.cos(yaw)*0.5, pos[2]+math.sin(yaw)*0.5)
        if 0 <= i < GRID_SIZE and 0 <= j < GRID_SIZE:
            grid[i][j] = 1
            # replan
            start = world_to_grid(pos[0], pos[2])
            path = astar(start, goal, grid)
            waypoints = [grid_to_world(a,b) for (a,b) in path]
            wp_index = 0
            print("Replanned path with", len(waypoints), "waypoints")

    if wp_index >= len(waypoints):
        stop(); print("GOAL REACHED!"); break

    target_x, target_y = waypoints[wp_index]
    dist = go_to_goal(pos, yaw, target_x, target_y)

    if dist < GOAL_THRESHOLD:
        wp_index += 1

stop()
print("Controller finished.")
