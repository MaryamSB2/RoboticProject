from controller import Supervisor, Keyboard
import math
import sys


motor_names = [
    "front left shoulder abduction motor",  "front left shoulder rotation motor",  "front left elbow motor",
    "front right shoulder abduction motor", "front right shoulder rotation motor", "front right elbow motor",
    "rear left shoulder abduction motor",   "rear left shoulder rotation motor",   "rear left elbow motor",
    "rear right shoulder abduction motor",  "rear right shoulder rotation motor",  "rear right elbow motor"
]

supervisor = Supervisor()
timestep = int(supervisor.getBasicTimeStep())

keyboard = Keyboard()
keyboard.enable(timestep)


me = supervisor.getSelf()
translation_field = me.getField('translation')
rotation_field = me.getField('rotation')


pos = translation_field.getSFVec3f()  
rot = rotation_field.getSFRotation()   

x, y, z = pos

if abs(rot[2]) > 0.9:
    yaw = rot[3]
else:
    yaw = 0.0


motors = []
for name in motor_names:
    m = supervisor.getDevice(name)
    m.setVelocity(4.0)
    m.setPosition(0.0)
    motors.append(m)


LEG_BASE_INDEX = [0, 3, 6, 9]


def set_leg(leg, hx, hy, kn):
    
    base = LEG_BASE_INDEX[leg]
    motors[base + 0].setPosition(hx)
    motors[base + 1].setPosition(hy)
    motors[base + 2].setPosition(kn)


def set_stand_pose():
    
    hx_vals = [-0.10, 0.10, -0.10, 0.10]  
    hy_vals = [0.0, 0.0, 0.0, 0.0]
    kn_vals = [0.0, 0.0, 0.0, 0.0]
    for leg in range(4):
        set_leg(leg, hx_vals[leg], hy_vals[leg], kn_vals[leg])


def animate_legs(phase, moving):
    
    if not moving:
        
        return

    
    hx_vals = [-0.15, 0.15, -0.15, 0.15]  

    
    amp_hy = 0.25    
    amp_kn = 0.35    
    base_kn = 0.25   

    
    phase_fl = phase
    phase_rr = phase
    phase_fr = phase + math.pi
    phase_rl = phase + math.pi

   
    fl_hy = amp_hy * math.sin(phase_fl)
    fr_hy = amp_hy * math.sin(phase_fr)
    rl_hy = amp_hy * math.sin(phase_rl)
    rr_hy = amp_hy * math.sin(phase_rr)

    
    fl_kn = base_kn + amp_kn * 0.5 * (1.0 - math.cos(phase_fl))
    fr_kn = base_kn + amp_kn * 0.5 * (1.0 - math.cos(phase_fr))
    rl_kn = base_kn + amp_kn * 0.5 * (1.0 - math.cos(phase_rl))
    rr_kn = base_kn + amp_kn * 0.5 * (1.0 - math.cos(phase_rr))

    
    def clamp(v, lo, hi):
        return max(lo, min(hi, v))

    fl_hy = clamp(fl_hy, -0.5, 0.5)
    fr_hy = clamp(fr_hy, -0.5, 0.5)
    rl_hy = clamp(rl_hy, -0.5, 0.5)
    rr_hy = clamp(rr_hy, -0.5, 0.5)

    fl_kn = clamp(fl_kn, 0.0, 1.0)
    fr_kn = clamp(fr_kn, 0.0, 1.0)
    rl_kn = clamp(rl_kn, 0.0, 1.0)
    rr_kn = clamp(rr_kn, 0.0, 1.0)

    # Apply
    set_leg(0, hx_vals[0], fl_hy, fl_kn)  
    set_leg(1, hx_vals[1], fr_hy, fr_kn)  
    set_leg(2, hx_vals[2], rl_hy, rl_kn) 
    set_leg(3, hx_vals[3], rr_hy, rr_kn)  



linear_speed = 0.4    
angular_speed = 0.8   
phase = 0.0
gait_frequency = 1.5  

print("Supervisor walk control ready:")
print("  Arrow Up    : move forward")
print("  Arrow Down  : move backward")
print("  Arrow Left  : turn left")
print("  Arrow Right : turn right")
print("  No key      : keep last leg pose, stop base")
print("  ESC         : quit")


set_stand_pose()


while True:
    
    forward_cmd = 0.0
    turn_cmd = 0.0

    key = keyboard.getKey()
    while key != -1:
       
        if key == Keyboard.UP:
            forward_cmd = 1.0
        elif key == Keyboard.DOWN:
            forward_cmd = -1.0
        elif key == Keyboard.LEFT:
            turn_cmd = 1.0
        elif key == Keyboard.RIGHT:
            turn_cmd = -1.0
        key = keyboard.getKey()

    
    if supervisor.step(timestep) == -1:
        sys.exit(0)
    dt = timestep / 1000.0

    moving = (abs(forward_cmd) > 0.0 or abs(turn_cmd) > 0.0)

    
    if moving:
        
        yaw += turn_cmd * angular_speed * dt

        
        dx = forward_cmd * linear_speed * math.cos(yaw) * dt
        dy = forward_cmd * linear_speed * math.sin(yaw) * dt

        x += dx
        y += dy

        translation_field.setSFVec3f([x, y, z])
        rotation_field.setSFRotation([0.0, 0.0, 1.0, yaw])

       
        phase += 2.0 * math.pi * gait_frequency * dt

    
    animate_legs(phase, moving)
